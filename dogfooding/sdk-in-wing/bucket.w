bring cloud;
bring "@cdktf/provider-aws" as tfaws;

class Utils {
  extern "./utils.js" static encode_uri(uri: str): str;
}

struct BucketProps {
  /**
   * Whether the bucket's objects should be publicly accessible.
   */
  public: bool = false;
}

/**
 * Bucket prefix provided to Terraform must be between 3 and 37 characters.
 *
 * Bucket names are allowed to contain lowercase alphanumeric characters and
 * dashes (-). We generate names without dots (.) to avoid some partial
 * restrictions on bucket names with dots.
 */
 let BUCKET_PREFIX_OPTS = NameOptions {
  max_len: 37,
  case: CaseConventions.LOWERCASE,
  disallowed_regex: /([^a-z0-9\-]+)/g,
  // add a dash to the end of the prefix to distinguish between the
  // Wing-generated portion of the name and the suffix generated by Terraform
  suffix: "-",
};

struct ListResult {
  items: Array<str>;
  marker: str?;
}

interface IBucketClient {
  inflight put_object(key: str, body: str): void;
  inflight get_object(key: str): str;
  inflight exists(key: str): bool;
  inflight get_location(): str;
  inflight list(prefix: str?, marker: str?): ListResult;
}

resource Bucket {
  bucket: tfaws.s3Bucket.S3Bucket;
  public: bool;

  init(props: str) {
    this.public = props.public;
    
    let bucket_prefix = ResourceNames.generate_names(this, BUCKET_PREFIX_OPTS);

    // names cannot begin with 'xn--'
    if bucket_prefix.starts_with("xn--") {
      throw "AWS S3 bucket names cannot begin with 'xn--'.";
    }

    // names must begin with a letter or number
    if (!/^[a-z0-9]/.test(bucket_prefix)) {
      throw "AWS S3 bucket names must begin with a letter or number.";
    }

    // names cannot end with '-s3alias' and must end with a letter or number,
    // but we do not need to handle these cases since we are generating the
    // prefix only

    this.bucket = new tfaws.s3Bucket.S3Bucket(bucket_prefix: bucket_prefix);

    // best practice: (at-rest) data encryption with Amazon S3-managed keys
    new tfaws.s3Bucket.S3BucketServerSideEncryptionConfigurationA(
      bucket: this.bucket.bucket,
      rule: [
        tfaws.s3Bucket.S3BucketServerSideEncryptionConfigurationRuleA {
          apply_server_side_encryption_by_default: tfaws.s3Bucket.S3BucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultA { 
            sse_algorithm: "AES256" 
          }
        },
      ],
    });

    if this.public {
      let policy = Json {
        Version: "2012-10-17",
        Statement: [
          {
            Effect: "Allow",
            Principal: "*",
            Action: ["s3:GetObject"],
            Resource: ["${this.bucket.arn}/*"],
          },
        ],
      };

      new tfaws.s3BucketPolicy.S3BucketPolicy(
        bucket: this.bucket.bucket,
        policy: Json.stringify(policy),
      );

    } else {
      new tfaws.s3BucketPublicAccessBlock.S3BucketPublicAccessBlock(
        bucket: this.bucket.bucket,
        blockPublicAcls: true,
        blockPublicPolicy: true,
        ignorePublicAcls: true,
        restrictPublicBuckets: true,
      );
    }
  }

  add_object(key: str, body: str) {
    new tfaws.s3Object.S3Object(
      bucket: this.bucket.bucket,
      key: key,
      content: body,
    ) as "S3Object-${key}";
  }

  override bind(host: core.IInflightHost, ops: str[]) {
    if ops.contains(cloud.BucketInflightMethods.PUT) || ops.contains(cloud.BucketInflightMethods.PUT_JSON) {
      host.add_policy_statements(
        effect: "Allow",
        action: ["s3:PutObject*", "s3:Abort*"],
        resource: ["${this.bucket.arn}", "${this.bucket.arn}/*"],
      );
    }

    if ops.contains(cloud.BucketInflightMethods.GET) || ops.contains(cloud.BucketInflightMethods.GET_JSON) {
      host.add_policy_statements(
        effect: "Allow",
        action: ["s3:GetObject*", "s3:GetBucket*", "s3:List*"],
        resource: ["${this.bucket.arn}", "${this.bucket.arn}/*"],
      );
    }


    if ops.contains(cloud.BucketInflightMethods.LIST) || ops.contains(cloud.BucketInflightMethods.PUBLIC_URL) {
      host.add_policy_statements({
        effect: "Allow",
        action: ["s3:GetObject*", "s3:GetBucket*", "s3:List*"],
        resource: ["${this.bucket.arn}", "${this.bucket.arn}/*"],
      );
    }

    if ops.contains(cloud.BucketInflightMethods.DELETE) {
      host.add_policy_statements(
        effect: "Allow",
        action: [
          "s3:DeleteObject*",
          "s3:DeleteObjectVersion*",
          "s3:PutLifecycleConfiguration*",
        ],
        resource: ["${this.bucket.arn}", "${this.bucket.arn}/*"],
      );
    }

    // The bucket name needs to be passed through an environment variable since
    // it may not be resolved until deployment time.
    host.add_environment(this.env_name(), this.bucket.bucket);
    host.add_environment(this.is_public_env_name(), "${this.public}");

    super.bind(host, ops);
  }

  is_public_env_name(): str {
    return "${this.env_name()}_IS_PUBLIC";
  }

  env_name(): str {
    return "BUCKET_NAME_${this.node.addr.slice(-8)}";
  }

  extern "./bucket.tfaws.js" inflight bucket_new_client(bucket_name: str): IS3Client;

  inflight s3_client: IBucketClient;

  inflight init() {
    this.s3_client = this.new_client(this.bucket_name);
  }

  inflight put(key: str, body: str) {
    this.s3_client.put_object(key, body);
  }

  inflight put_json(key: str, body: json) {
    this.put(key, Json.stringify(body));
  }

  inflight get(key: str): str {
    return this.s3_client.get_object(key);
  }

  inflight get_json(key: str): json {
    return json.parse(this.get(key));
  }

  /*private*/ inflight exists(key: str): bool {
    return this.s3_client.exists(key);
  }

  /*private*/ inflight get_location(): str {
    return this.s3_client.get_location();
  }

  /**
   * Returns a url to the given file.
   * @Throws if the file is not public or if object does not exist.
   */
  inflight public_url(key: str): str{
    if !this.public {
      throw "Cannot provide public url for a non-public bucket";
    }

    if !this.exists(key) {
      throw "Cannot provide public url for an non-existent key (key=${key})";
    }
    
    let region = this.get_location();
    return Utils.encode_uri("https://${this.bucketName}.s3.${region}.amazonaws.com/${key}");
  }

  /**
   * Returns a signed url to the given file. This URL can be used by anyone to
   * access the file until the link expires (defaults to 24 hours).
   * @param key The key to reach
   * @param duration Time until expires
   */
  inflight signed_url(key: str, time?: duration): str {
    // for signed_url take a look here: https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/s3-example-creating-buckets.html#s3-create-presigendurl-get
    throw "signed_url is not implemented yet (key=${key}, duration=${time})";
  }

  /**
   * List all keys in the bucket.
   * @param prefix Limits the response to keys that begin with the specified prefix
   * TODO - add pagination support, currently returns all existing keys in the bucket
   */
  inflight list(prefix: str?): Array<str> {
    let items = MutArray<str>[];
    let var marker: str?;
    let var more = true;

    while more {
      let result = this.s3_client.list(prefix: prefix, marker: marker);
      marker = result.marker;
      items.extend(result.items);
      more = marker?;
    }

    return list;
  }

  /**
   * Delete an existing object using a key from the bucket
   * @param key Key of the object.
   * @param opts Option object supporting additional strategies to delete an item from a bucket
   */
  inflight delete(key: str, opts: BucketDeleteOptions = {}) {
    this.s3_client.delete(key, opts);
  }  
}

struct BucketDeleteOptions {
  /**
   * Check failures on the method and retrieve errors if any
   * @Throws if this is `true`, an error is thrown if the file is not found (or any error case).
   */
   must_exist: boolean = false;
}

/**
 * Options for `ResourceNames.generate_name`
 */
struct NameOptions {
  /**
   * Maximum length for the generated name. The length must at least the length
   * of the hash (8 characters).
   * @default - no maximum length
   */
  max_len: num?;

  /**
   * Regular expression that indicates which characters are invalid. Each group
   * of characters will be replaced with `sep`.
   */
  disallowed_regex: str;

  /**
   * Word breaker
   */
  sep: str = "-";

  /**
   * Convert the generated name to all uppercase or all lowercase.
   * @default - apply no case conversion
   */
  case: CaseConventions?;

  /**
   * Apply a predefined prefix to the generated name
   * @default - no prefix
   */
  prefix: str?;

  /**
   * Apply a predefined suffix to the generated name
   */
  suffix: str = "";

  /**
   * Include a hash of the resource's address in the generated name.
   *
   * This should only be disabled if the resource's name is guaranteed to be
   * app-unique, or if some other source of randomness will be appended to the
   * name.
   */
  include_hash: bool = true;
}

enum CaseConventions {
  LOWERCASE,
  UPPERCASE,
}

class ResourceNames {
  static generate_names(resource: Resource, props: NameOptions) {
    if let len = props.max_len {
      if len < 8 {
        throw("max_len must be at least 8");
      }
    }

    let var name = resource.node.id;

    let apply_case_conversion = () => {
      if let case = props.case {
        if case == CaseConventions.LOWERCASE { return name.lowercase(); }
        if case == CaseConventions.UPPERCASE { return name.uppercase(); }
      }
      return name;
    };

    if let prefix = props.prefix {
      name = "${prefix}${name}";
    }

    let var hash: str = "";
    if props.include_hash {
      hash = sep + resource.node.addr.substring(0, 8);
    }

    // TODO: RegEx support?!
    name = name.replace(props.disallowed_regex, sep);

    // TODO: allow customizing where we "trim" the name, e.g.
    // 1. trim from the end
    // 2. trim from the beginning
    // 3. trim from the middle
    if props.max_len {
      name = name.substring(0, props.max_len - hash.len - suffix.len);
    }

    name = "${name}${hash}${suffix}";

    // apply case conversion again in case the prefix, suffix, or hash is not
    // case-conformant
    return apply_case_conversion();
  }
}
